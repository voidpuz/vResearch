# Chapter 2: Basic Commands and Directory Hierarchy

### Standard Input and Standard Output
Unix processes use I/O streams to read and write data. Streams are very flexible: a source of an input stream can be a file, a device, a terminal window or even the output stream of the another process. To observe this, simply type `cat` and press ENTER. The program starts to wait for your input from input stream to do its work, as you didn't specify from which file it should read. So, in this case Terminal's output stream is being cat's input stream.

### Basic Commands
- `cat /etc/passwd`
- `cat file1.conf file2.txt`
- `ls -l`
- `cp file1.txt file2.txt` - file1 is copied into file2
- `cp file dir` - file is copied into dir
- `cp file1 file2 file3 dir` - multiple files are copied into dir
- `mv file1 file2` - renames file1 as file2
- `touch file` - creates a file
- `ls -l file` - shows file information with permissions
- `rm file` - removes the file

### Navigating Directories
- `cd dir` - changes current directory to dir (opens dir)
- `mkdir dir` - makes a new dir
- `rmdir dir` - removes the dir

### Shell Globbing (Wildcards)
Shell can match simple patterns to file and directory names. 
- `echo *` - any number of arbitrary characters (lists files in a current directory)
- `("msg*", "*msg", "*msg*")` - [0] expands to all filenames that start with msg, [1] expands to all filenames end with msg, [3] expands to all filenames contain msg
- `br?t` - ? glob expands to exactly 1 character - matching `brat` and `brot` in this example

### Intermediate Commands
- `grep root /etc/passwd` - prints the lines from a file or input stream that match an expression. Here, it prints lines in `/etc/passwd` file that contain text root
    -> `grep -i` - matches case-insensitive
    -> `grep -v` - inverts the search (lists not matching)
    -> grep understands regex: 
	- `grep root /etc/.*` - matches any number of chars, including none.
    	- `grep root /etc/.+` - matches any one or more chars.
	- `grep root /etc/.` - matches exactly one arbitrary char.
- `less file` - opens file with scroll option. Handy if a file or output stream is too big. For example, `grep ie /usr/share/dict/words | less` is giving all of the words containing `ie` as input stream to less, and it shows the result with scrolling option.
- `pwd` - print working directory
- `diff file1 file2` - see differences between 2 text files
- `file file` - let system guess the type of file
- `find dir -name file -print` - finds a file in directory dir and prints the location
- `head file.txt` - shows first 10 lines of the file. Use `-n` option to specify size
- `tail file.txt` - shows last 10 lines of the file. Use `-n` option to specify size
- `sort file` - sorts the file in alphanumeric order. `-r` for reverse, `-n` for sorting by numerical order only.


### Changing your password
- `passwd` - command help to change your password by typing current password first and a new one.

### Environment and Shell Variables
The shell can store temporary variables, called **shell variables**. For example:
```bash
$ STUFF=ls
$ $STUFF
# ... (ls)
```

An **environment variable** is a bit different. All processes on Unix systems have envvar storage. The primary difference is, evironment variables are accessible from any program ran by that shell (process), whereas shell variables can't be used with processes ran by that shell.
To assign an envvar:
```bash
STUFF=something
export STUFF
```

### The Command Path
PATH is a special envvar that contains a list of system dirs that shell searches when we type. For example, if we write `ls` on terminal, it searches the following dirs by default to find `ls` program:
```bash
ubuntu@ubuntu2404server:/etc$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin
```
We also can tell the shell to look for other directories:
```bash
$ PATH=dir:$PATH
# or to append a dir
$ PATH=$PATH:dir
```

> ‚ùì Even if you wipe out your PATH accidentally, this change is local. Because envvars are stored locally in each process' address space, simply exiting the shell and opening a new one solves the problem.

